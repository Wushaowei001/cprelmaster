#+TITLE:     Constraint Programming on Relations: theory, practice and implementation
#+AUTHOR:    Gustavo Gutierrez-Sabogal
#+EMAIL:     gustavo.ggutierrez@gmail.com
#+DATE:      2011-08-29 Mon
#+DESCRIPTION: 
#+KEYWORDS: 
#+LANGUAGE:  en
#+OPTIONS:   H:4 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 


#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \newcommand{\universe}[1]{\ensuremath{\mathcal{U}_{#1}}}
#+LATEX_HEADER: \newcommand{\emptyrel}[1]{\ensuremath{\emptyset_{#1}}}
#+LATEX_HEADER: \newcommand{\tuple}[1]{\ensuremath{\langle t_{1},\ldots,t_{#1} \rangle}}
#+LATEX_HEADER: \newcommand{\art}[1]{\ensuremath{arity(#1)}}
#+LATEX_HEADER: \newcommand{\compl}[1]{\ensuremath{\lnot #1}}
#+LATEX_HEADER: \newcommand{\inter}[2]{\ensuremath{#1\cap #2}}
#+LATEX_HEADER: \newcommand{\proj}[2]{\ensuremath{\underset{\scriptstyle #1}{\prod}(#2)}}
#+LATEX_HEADER: \newcommand{\perm}[2]{\ensuremath{\underset{\scriptstyle #2}{\sigma}(#1)}}
#+LATEX_HEADER: \newcommand{\join}[3]{\ensuremath{#1 \underset{\scriptstyle #2}{\Join} #3}}
#+LATEX_HEADER: \newcommand{\follow}[3]{\ensuremath{#1 \underbracket{\scriptstyle #2}_{\scriptstyle \/} #3}}
#+LATEX_HEADER: \newcommand{\followall}[3]{\ensuremath{#1 \underbracket{\scriptstyle #2}_{\scriptstyle \forall} #3}}
#+LATEX_HEADER: \DeclareMathOperator{\glbo}{glb}
#+LATEX_HEADER: \newcommand{\glb}[1]{\ensuremath{\glbo(#1)}}
#+LATEX_HEADER: \DeclareMathOperator{\lubo}{lub}
#+LATEX_HEADER: \newcommand{\lub}[1]{\ensuremath{\lubo(#1)}}
#+LATEX_HEADER: \DeclareMathOperator{\unko}{unk}
#+LATEX_HEADER: \newcommand{\glb}[1]{\ensuremath{\unko(#1)}}
#+LATEX_HEADER: \DeclareMathOperator{\suffix}{suffix}
#+LATEX_HEADER: \DeclareMathOperator{\concat}{concat}
#+LATEX_HEADER: \DeclareMathOperator{\match}{match}
#+LATEX_HEADER: \DeclareMathOperator{\prefix}{prefix}
#+LATEX_HEADER: \DeclareMathOperator{\nth}{nth}

* TODO [0%] General things to be done 				   :noexport:
** TODO Create the converter to use Context instead of latex 
** TODO Improve latex definitions for the relation operations shortcuts 
** TODO design the follow operator in tikz 
** TODO Improve the definition of the tuple command in latex.
** TODO Change the mode from article to book when exporting the document
* Introduction
** Contributions
** Related work
* TODO [%] Relations as ground values :noexport:
** TODO explain that a relation is a set of tuples.
   For now it does not matter how tuples are considered or which kind
   of elements do they contain.
** TODO explain that there is a formal model behind relations: the relational algebra. :noexport:
** TODO explain that there are two ways of see a relation, as a set or by columns. :noexport:

* Relations as ground values
** What is a relation?
** The relational algebra notion of a relation or table
** Relations in constraint programming
   An important difference from relational algebra is that the
   universe of elements is finite in constraint
   programming and this allow us to assume that operations like
   /complement/ of relations are semantically well defined.
   
   As we are restricted to integers as elements in any relation we
   define the set \universe{} as the biggest set containing all the
   integers that can appear as elements in relations. 
   
   \begin{align*} 
   \universe{} = \{x : 0 \leq x \leq k \} 
   \end{align*}
   
   In this definition, $k$ represents an arbitrary big number that
   is fixed only for implementation purposes.
   
   After this definition of elements, we define a tuple as an
   ordered list of elements of \universe{}. A tuple $t$ of $n$
   elements is represented:
   
   \begin{align*} 
   t = \tuple{n}
   \end{align*}
  
   The number of elements in a tuple is called its /arity/. For the
   example above we have that $\art{t}=n$. To refer to the elements
   at specific positions in the tuple we use the notation $\nth(t,k)$
   which will refer to the element at position $k$ of tuple $t$.
   
   With the definitions of tuple and the universe we can define for
   instance the universe of all the possible tuples of arity 2 as
   $\universe{}\times\universe{}$. In a general way we define:
   
   \begin{align*}
   \universe{}_k = \underbrace{\universe{}\times\ldots\times\universe{}}_{k-times}
   \end{align*}
   
   as the universe for al the tuples of arity $k$. A relation is
   consider asa set of tuples of the same arity and because of this
   we write $R\subseteq\universe{k}$ to represent that $R$ is a set
   of tuples of arity $k$.
     
   It is also important to define the empty set as the set that does
   not contain any tuple. In the same way that \universe{n}
   represents the universe of all the tuples of arity $n$ we define
   \emptyrel{n} as the empty set for tuples of the same arity.
   
** Operations on relations
   Even when restricting the elements of a relation to be in
   $\universe{}$ we can still define the usual operations in relations
   that are presented in the relational algebra. A first group of
   operations deal with relations as if they were sets:

*** Complement
    The complement of a relation $R\subseteq\universe{n}$ is the relation: 
    
    \begin{align*}
    \compl{R} = \{t : t \in \universe{n} \land t \notin R\}
    \end{align*}
    
*** Intersection
    The intersection of two relations $R$ and $S$, both of them of
    the same arity, is the relation:
    
    \begin{align*}
    \inter{R}{S} = \{t : t \in R \land t \in S \}
    \end{align*}

    With this two operations it is possible to define other operations
    like union, subset, etc.. Table \ref{tab:derived-relations}
    presents a list of other operations that we can get from
    complement and intersection.

    #+CAPTION: Other operations that can be derived from complement and intersection.
    #+LABEL:   tab:derived-relations
    |----------------+------------|
    | Operation      | Equivalent |
    |----------------+------------|
    | $R\cup S$      |            |
    | $R\subseteq S$ |            |
    | $R\iff S$      |            |
    |----------------+------------|
    
    Apart from these operations we can also use the ones from the
    relational algebra.
    
*** Projection
    Projecting a relation allows to obtain a relation of less
    arity. The operation takes two parameters: the relation itself and
    the set of columns to project on. For instance consider the follow
    relation:
     |-------+-------+-------|
     | C_{1} | C_{2} | C_{3} |
     |-------+-------+-------|
     |    42 |     5 |    38 |
     |    21 |     7 |     9 |
     |    43 |    12 |     1 |
     |-------+-------+-------|

    The relation resulting from projecting the relation above on the
    set of columns $\{C_{2},C_{3}\}$ is the relation:
    |-------+-------|
    | C_{1} | C_{2} |
    |-------+-------|
    |     5 |    38 |
    |     7 |     9 |
    |    12 |     1 |
    |-------+-------|

    Formally, projection a relation $R \subseteq \universe{n}$ on a
    set $P$ of column indexes, denoted  \proj{P}{R}, is defined as: 
    \begin{align*}
    \forall t \in R  \implies \exists t' \in \proj{P}{R}: \arity{t'}=|P|
    \land \forall i \in P : \nth(t',i) = \nth(t,i)
    \end{align*}

    We can deduce from this definition that
    $\proj{P}{R}\subseteq\universe{|P|}$. Moreover, projecting a
    relation on a set that contains all its columns will give as
    result the same relation while projecting it on an empty set will
    give \emptyrel{0}.
*** Quantification
**** Universal
**** Existencial
**** Unique
*** Permutation
    This operation allows to perform column reordering on
    relations. The parameters are:
    
    - A relation $R\subseteq\universe{n}$ to be permuted, and
    - a relation $P\subseteq\universe{2}$ that specifies how columns in
      the resulting relation correspond to columns in $R$.

    As an example consider the following relation to permute:
    |-------+-------+-------|
    | C_{1} | C_{2} | C_{3} |
    |-------+-------+-------|
    |    42 |     5 |    38 |
    |    21 |     7 |     9 |
    |    43 |    12 |     1 |
    |-------+-------+-------|

    and the permutation relation:
    |-------+-------|
    | C_{1} | C_{2} |
    |-------+-------|
    |     1 |     3 |
    |     2 |     2 |
    |     3 |     1 |
    |-------+-------|
    
    that describes that column 1 will be permuted with column 3 and
    that column 2 will remain at the same position. The resulting
    permutation is:
    |-------+-------+-------|
    | C_{3} | C_{2} | C_{1} |
    |-------+-------+-------|
    |    38 |     5 |    42 |
    |     9 |     7 |    21 |
    |     1 |    12 |    43 |
    |-------+-------+-------|

    This operation is well defined if and only if $P$ is injective and
    surjective and:

    \begin{align*}
    &\forall x, y : (x,y) \in $P$ \implies x \in C(R) \land y \in C(R) \\
    &C(R)=\{1,\ldots,n\}
    \end{align*}
      
    The result of permuting a relation $R\subseteq\universe{n}$ with
    respect to a relation $N\subseteq \universe{2}$;  denoted
    \perm{R}{N} is defined as:
    
    \begin{align*}
    \forall t \in R  \implies \exists t' \in \perm{R}{N}: \forall i
    \in C(R) : \nth(t,i) = \nth(t',N(i))
    \end{align*}
    
*** TODO Join :noexport:
**** TODO [%] Define the following operations formally.
***** TODO Introduce the notion of Follow or division
    
*** Join
    
    Before introducing this operation we will introduce three
    different concepts on tuples that will be used by the definitions.
    Given the tuple $t=<t_1,\ldots,t_i,\ldots,t_n>$, we define:
    
    - $\prefix(t,i)$ :: the tuple of arity $i$ that contains the first
      $i$ elements of $t$.
    - $\suffix(t,i)$ :: the tuple of arity $i$ that contains the last $i$
      elements of $t$.
    - $\match(t,t',l)$ :: a boolean function that evaluates to /true/ if
      $\suffix(t,l)=\prefix(t',l)$ and /false/ otherwise.
    - $\concat(t,u)$ :: is the tuple resulting from appending tuples $t$
      and $u$.

    The join operation take two relations $R\subseteq\universe{n}$ and
    $S\subseteq\universe{m}$ as arguments. Additionally it takes an
    integer $j$ that describes on how many columns the join operation is
    going to be performed. The resulting relation, denoted $\join{R}{j}{S}$
    is a subset of $\universe{n+m-j}$ and is defined:
    
    \begin{align*}
    \forall r \in R \forall s \in S : match(r,s,j) \implies
    \concat(r,\suffix(s,m-j)) \in  \join{R}{j}{S}
    \end{align*}
    
    As an example, consider the two relations:
    |-------+-------+-------|
    | C_{1} | C_{2} | C_{3} |
    |-------+-------+-------|
    |    42 |     5 |    38 |
    |    21 |     7 |     9 |
    |    43 |    12 |     1 |
    |-------+-------+-------|
    
    |-------+-------+-------|
    | C_{3} | C_{2} | C_{1} |
    |-------+-------+-------|
    |     5 |    38 |     2 |
    |     5 |    38 |     4 |
    |    12 |     1 |     3 |
    |-------+-------+-------|

    The result of joining both relations on $j=2$ columns is:
    
    |-------+-------+-------+-------|
    | C_{1} | C_{2} | C_{3} | C_{4} |
    |-------+-------+-------+-------|
    |    42 |     5 |    38 |     2 |
    |    42 |     5 |    38 |     4 |
    |    43 |    12 |     1 |     3 |
    |-------+-------+-------+-------|

    An special case of the join operation is when $j=0$. From the
    definition, $match(t,u,0)$ will evaluate to /true/ always. In this
    case every possible combination of tuples will be part of the result
    and therefore it represents the cartesian product of the two
    relations.

    \begin{align*}
    R \times S = \join{R}{0}{S}
    \end{align*}
    
*** Summarizing (notion of cardinality)
* Relations as decision variables
   They represent a relation out of a possible sets of relations.
** Domain definition
*** What it really is in the mathematical sense
**** Lattice and power set definitions
***** Minimal and maximal elements
***** Operations that increase information in the lattice
*** How does is it approximated
*** How does is it implemented
** Kernel constraints
** Cardinality
* Constraints on relation decision variables
** Sets-like constraints
*** Complement
*** Intersection
** Relation-like constraints
*** TODO [0%] Projection 					   :noexport:
**** TODO Complete the explanation for the pruning of A in this constraint.
**** TODO Explain that the constraint takes a number of columns on the right part and not a set with column indices
*** Projection

   This constraints enforces that a relation decision variable
   $B\subseteq\universe{m}$ is the result of projecting another
   decision variable $A\subseteq\univers{n}$ on the set of column
   indices $P$. It is written:
   
   \begin{align*}
   \proj{P}{A} \equiv B
   \end{align*}

   For this constraint to be well defined we required:
   - $m=|P|$: preserves the requirements of the /join
		operation/ on relations.
   - $\forall x \in P : 1 \leq x \leq n$: ensures
	that $P$ only contains valid column indices.

     
   The pruning that this constraint is going to perform on both
   variables can be defined by the following propagation rules:
   - Pruning $A$: :: The fact that $n\geq m$ makes the pruning that
		     can be performed on $A$ weaker than the pruning
		     done for the other direction of the
		     constraint.
     - Consider tuples $\{a_0,a_1\}\subseteq \unk{A}$
       and $b\in \glb{B}$.
     - $\proj{P}{\{a_0,a_1\}}=\{b\}$ means that both $a_0$ and $a_1$
       can be valid supports for $b$. However this does not represents enough
       information to deduce that one or the other must be included
       in $A$. this decision can be taken only when we know that the
       support is unique.
     - If for some reason, all but one of the supports of $b$ become
       no longer part of the variable we need to include the
       remaining one in order to keep the constraint consistent.
     - Finally new bounds for $A$ are:
       - $\lub{B}\times\universe{n-p} \supseteq A$
       - $A \subseteq Uq\cap(\universe{n-p}\times\glb{B})$, where
	 $Uq$ represents the unique quantification of the elements in
	 the upper bound of $A$. This is, $Uq = (\exists!_{\{p+1,\ldots,n\}}\lub{A})\cap\lub{A}$

   - Pruning $B$: :: In this case it is enough to apply the
		     projection operation on both the lower and upper
		     bounds of $A$ to find the new bounds:
     - $B \subseteq \proj{P}{\glb{A}}$
     - $\proj{P}{\lub{A}} \supseteq B$
   
*** Permutation
*** Join
*** TODO [%] Follow :noexport:
**** TODO Write on the disadvantages of the implementation of this constraint in the well known case
**** TODO Elaborate on the notion of division in relational algebra and the correspondence to Follow
*** Follow
    \begin{align*}
    \follow{A}{f}{B}\equiv C
    \end{align*}
   
*** TODO [%] FollowAll :noexport:
**** TODO Explain why the FollowAll constraint can be expressed in terms of Follow
*** FollowAll
    \begin{align*}
    \followall{A}{f}{B}\equiv C
    \end{align*}

    This constraint is equivalent to:

    \begin{align*}
    \follow{A}{f}{\compl{B}}\equiv \compl{C}
    \end{align*}

**** TODO The following tables are work in progress and can be even incorrect

     |--------+--------+---------+--------+---------|
     | \vdots | \vdots | y_1     | \ldots | z_1     |
     | \vdots | \vdots | y_2     | \ldots | z_2     |
     | w      | x      | \vdots  | \ldots | \vdots  |
     | \vdots | \vdots | y_{n-1} | \ldots | z_{n-1} |
     | \vdots | \vdots | y_n     | \ldots | z_n     |
     |--------+--------+---------+--------+---------|

     followed by $|\{y_1,\ldots,z_1\}|$
     |---------+--------+---------+--------+--------|
     | y_0     | \ldots | z_0     | \vdots | \vdots |
     | y_1     | \ldots | z_1     | \vdots | \vdots |
     | y_2     | \ldots | z_2     | \vdots | \vdots |
     | \vdots  | \ldots | \vdots  | a      | b      |
     | y_{n-1} | \ldots | z_{n-1} | \vdots | \vdots |
     | y_n     | \ldots | z_n     | \vdots | \vdots |
     |---------+--------+---------+--------+--------|

*** FAAA
*** Summarize
* Relation with other decision variables
** TODO [%] Set decision variables :noexport:
*** TODO Mention channel constraint between a relation variable and an array of set vars
*** TODO Is it possible to say something about the cardinality here?
** Set decision variables
  From a mathematical point of view we can appreciate some
  similarities between relations and sets. For this reason is not
  surprising that also the decision variables share basically the same
  aspects.
  - A relation is a set of tuples. If we consider that a tuple can
    have any arity and therefor in particular one we can see that a
    relation of arity one is the same as a set. This applies to both,
    constant relations and decision variables. This similarity is
    exploited in the system by providing a channel constraint between
    a set and a relation decision variable.
  - Projecting a relation on one of its columns will give as result a
    set. This is an straight forward statement from the definition of
    the projection operation where its result will be a relation with
    the arity being equal to the cardinality of the set of column
    indices. There is no special constraint that exploits this
    similarity because this can be handled by the constraint mentioned
    in the item above.
** Integer decision variables
** Boolean variables
* Domain representation
** Which properties do we expect from the domain representation
*** Time complexity
**** Read operations happen often than write operations
*** Space complexty
*** A first approach, extentional
*** Binary decision diagrams to represent the domain
**** They have been used for complete domain representation of set decision variables.
* System's implementation
** An overview of the implementation of the system
*** Project website
    The implementation of the constraint system is available
    online. The documentation along with instructions on how to build
    it are available at: http://ggutierrez.github.com/cprelmaster/ and
    the development site where bugs can be submitted is:
    https://github.com/ggutierrez/cprelmaster.
**** Setup instructions
***** Supported operating systems
***** Requirements
***** Building
***** Installation
      
** Libraries used to implement it
*** Gecode
**** Variable specification
**** Complexity of the propagators
     In this case Gecode presents an advantage as its state of the art
     implementation of the propagation engine makes a more efficient
     use of the resources.
*** TODO CUDD :noexport:
**** TODO Complete with other ground relations that are implemented by CUDD and that we use directly. 
*** CUDD
    This is the library that we use to support the implementation of
    the domain representation of the constraint system. [[http://vlsi.colorado.edu/~fabio/CUDD/][CUDD]] presents
    several strong points that we take advantage of.

    - Provides support for implementing the domain representation
    - It has several advantages over the use of other libraries. For
      instance it provides a real implementation of complemented
      edges. Other libraries just implement ADDs and they do not
      provide the same time complexities guaranties.
    - Its use causes some interference with the parallel search
      architecture provided by Gecode. To maximize the possible
      sharing a /manager/ is used to store several /BDDs/ then what
      will happen if several threads try to access the same variable
      representation?.
    - It already provides some constant bdd representation for
      different constant relations. We do a direct use of them.
      - $R(x,y) = \{(x,y) : x = y\}$
      - $R(x,y) = \{(x,y) : x > y\}$
      - Others....

*** Other /BDD/ libraries
**** Buddy
     The [[http://buddy.sourceforge.net/manual/main.html][Buddy]] library.
**** JINC
     The [[http://jossowski.de/projects/jinc/jinc.html][JINC]] library.
     
     - Support for multithreading
     - Modern object oriented design

** Relation encoding on /BDDs/
** Simple program using relation constraints
* Study case: the package installability problem
** Constraint model
** Variables
** Constraints
** Search heuristics
** Benchmarks
** Other approaches that solve the problem
* Study case: music composition 
* PIP infrastructure
** Model and interaction among components
** Implementation
*** TODO [%] Parser implementation
**** TODO Bison %code directive
     When I tried to build the parser in Mac OSX the %code directive
     is not supported by the bison version shipped with mac. This
     directive is needed in Linux because otherwise the code included
     by it wont be present at the right place in the generated file.

     As a workaround in mac we can use the a normal prologue section:
     %{ %}
*** A parser from CUDF to KCUDF
*** TODO [%] libkcudf implementation
**** TODO cmake file is out of date with my knowledge of cmake
**** TODO drop the support for universal binaries and provide only support for gcc generic options
**** TODO remove the use of std::list where possible
*** Kernel-CUDF language
    The goal is to have something that is solver friendly in the sense
    that it can be easily parsed by it.
**** Language definition
**** Tools
     It consists of several components that interact together:
     - Translator: :: takes CUDF as an input and provides a KCUDF
                      representation of it.
     - Reducer: :: given a KCUDF specification this process tries to
                   find all the components of it that must participate
                   in the solving process.

* Experiments
** TODO [%] Implementation
*** TODO segmentation fault when iterating on the files of a directory
    This is produced on mac when using filesystem3 and the custom
    compiled gcc. Apple's gcc works fine.
*** TODO more information from the reducer is needed.
    We need to know how many relations the reducer was able to drop
    because they were not needed. Also think about other useful
    information that can complement this.
** Size of the relations in the package installability problem

   - General statistics that show how the tools perform on several
     instances.
     
     |-----------------------------+----------------+--------------------+-----------------+------------------|
     | Problem                     | Parsing (sec.) | Translating (sec.) | Reducing (sec.) | Date             |
     |-----------------------------+----------------+--------------------+-----------------+------------------|
     | codebreaker.cudf            |        7.47771 |             9.2886 |         3.38545 | <2011-09-02 Fri> |
     | dpkg-dev.cudf               |        7.44725 |            9.29764 |         3.47013 | <2011-09-02 Fri> |
     | fcron.cudf                  |        7.48727 |            9.40373 |          3.4305 | <2011-09-02 Fri> |
     | libgnokii4.cudf             |        7.52728 |            9.42241 |          3.4593 | <2011-09-02 Fri> |
     | libnss3-1d.cudf             |        7.49822 |            9.35437 |         3.49358 | <2011-09-02 Fri> |
     | mercurial-common.cudf       |        7.49112 |            9.49861 |         3.48125 | <2011-09-02 Fri> |
     | mono-gac.cudf               |        7.65299 |            9.38672 |         3.57372 | <2011-09-02 Fri> |
     | openoffice.org-l10n-da.cudf |        7.59518 |            9.48585 |         3.54366 | <2011-09-02 Fri> |
     | tasque.cudf                 |        7.57444 |            9.44606 |         3.52883 | <2011-09-02 Fri> |
     | unattended-upgrades.cudf    |        7.61505 |            9.51398 |         3.51486 | <2011-09-02 Fri> |
     |-----------------------------+----------------+--------------------+-----------------+------------------|

   - Translation specific statistics
     |-----------------------------+----------------+-----------------|
     | Problem                     | Installed Pkgs | Consistent Pkgs |
     |-----------------------------+----------------+-----------------|
     | codebreaker.cudf            |           2961 |            2896 |
     | dpkg-dev.cudf               |           2960 |            2896 |
     | fcron.cudf                  |           2961 |            2896 |
     | libgnokii4.cudf             |           2960 |            2896 |
     | libnss3-1d.cudf             |           2960 |            2896 |
     | mercurial-common.cudf       |           2960 |            2896 |
     | mono-gac.cudf               |           2960 |            2896 |
     | openoffice.org-l10n-da.cudf |           2960 |            2896 |
     | tasque.cudf                 |           2960 |            2896 |
     | unattended-upgrades.cudf    |           2960 |            2896 |
     |-----------------------------+----------------+-----------------|
   
   - Reducer specific statistics


   Experiments were taken in:
   - Darwin snyders.info.ucl.ac.be 10.8.0 Darwin Kernel Version
     10.8.0. root:xnu-1504.15.3~1/RELEASE_I386 i386
   - Te reported time corresponds to the /real/ field of the output of
     the *time* command. 

