<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Domain representation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="http://www.mathjax.org/mathjax/MathJax.js">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>Domain representation</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPG_1_1CPRel_1_1VarImpl_1_1BddManager.html">BddManager</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to handle the creation and destruction of Cudd related objects.The idea of having this class is to create a global object that is in charge of the resource deallocation of Cudd entities. For this reason only one manager is used and this class implements the singleton pattern.  <a href="classMPG_1_1CPRel_1_1VarImpl_1_1BddManager.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPG_1_1CPRel_1_1VarImpl_1_1RelationImplIter.html">RelationImplIter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to iterate on tuples of a relation implementation.  <a href="classMPG_1_1CPRel_1_1VarImpl_1_1RelationImplIter.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5f205ebc452d30ae7f30d2166364a639"></a><!-- doxytag: member="DomRepr::BOOST_STATIC_ASSERT" ref="ga5f205ebc452d30ae7f30d2166364a639" args="(std::numeric_limits&lt; int &gt;::digits&lt;=bitsPerInteger &amp;&amp;&quot;The BDD configuration is wrong for this built&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#ga5f205ebc452d30ae7f30d2166364a639">BOOST_STATIC_ASSERT</a> (std::numeric_limits&lt; int &gt;::digits&lt;=bitsPerInteger &amp;&amp;&quot;The BDD configuration is wrong for this built&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the library is compiled on an architecture in which the bits in an integer fits in the bdd representation. This is because most of the operations on tuples or anything that has a bdd representation behind use the int type to input and output values. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafae4a22cb1b6d26e31466e6f7addd84d"></a><!-- doxytag: member="DomRepr::dd" ref="gafae4a22cb1b6d26e31466e6f7addd84d" args="(void)" -->
DdManager *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#gafae4a22cb1b6d26e31466e6f7addd84d">dd</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the manager. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga15dda2c1c55f5d087d75845a65d36cf9"></a><!-- doxytag: member="DomRepr::one" ref="ga15dda2c1c55f5d087d75845a65d36cf9" args="(void)" -->
DdNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#ga15dda2c1c55f5d087d75845a65d36cf9">one</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns logical true. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gace018779ad95273deb3bbaebda1068ee"></a><!-- doxytag: member="DomRepr::zero" ref="gace018779ad95273deb3bbaebda1068ee" args="(void)" -->
DdNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#gace018779ad95273deb3bbaebda1068ee">zero</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns logical false. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae68bafa41f6cf8cd2bfe9f5c267ceb05"></a><!-- doxytag: member="DomRepr::operator==" ref="gae68bafa41f6cf8cd2bfe9f5c267ceb05" args="(const RelationImpl &amp;r, const RelationImpl &amp;s)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#gae68bafa41f6cf8cd2bfe9f5c267ceb05">operator==</a> (const RelationImpl &amp;r, const RelationImpl &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether two relations are the same. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga25917a8867df865a934733d79e77b68a"></a><!-- doxytag: member="DomRepr::operator!=" ref="ga25917a8867df865a934733d79e77b68a" args="(const RelationImpl &amp;r, const RelationImpl &amp;s)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#ga25917a8867df865a934733d79e77b68a">operator!=</a> (const RelationImpl &amp;r, const RelationImpl &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether two relations are different. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2e6470b7418ff29f456e7c00bdc17080"></a><!-- doxytag: member="DomRepr::Union" ref="ga2e6470b7418ff29f456e7c00bdc17080" args="(const RelationImpl &amp;r, const RelationImpl &amp;s)" -->
RelationImpl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#ga2e6470b7418ff29f456e7c00bdc17080">Union</a> (const RelationImpl &amp;r, const RelationImpl &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of relations <em>r</em> and <em>s</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf890af423e68ee54951964241f3b184a"></a><!-- doxytag: member="DomRepr::intersect" ref="gaf890af423e68ee54951964241f3b184a" args="(const RelationImpl &amp;r, const RelationImpl &amp;s)" -->
RelationImpl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#gaf890af423e68ee54951964241f3b184a">intersect</a> (const RelationImpl &amp;r, const RelationImpl &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection between relations <em>r</em> and <em>s</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5a1ffeaa74a6b66350b98f532c571c79"></a><!-- doxytag: member="DomRepr::subsetEq" ref="ga5a1ffeaa74a6b66350b98f532c571c79" args="(const RelationImpl &amp;r, const RelationImpl &amp;s)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#ga5a1ffeaa74a6b66350b98f532c571c79">subsetEq</a> (const RelationImpl &amp;r, const RelationImpl &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subset: \( r \subseteq s \). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga75160386eb49fe1a094ec4593da0f1d8"></a><!-- doxytag: member="DomRepr::supersetEq" ref="ga75160386eb49fe1a094ec4593da0f1d8" args="(const RelationImpl &amp;r, const RelationImpl &amp;s)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#ga75160386eb49fe1a094ec4593da0f1d8">supersetEq</a> (const RelationImpl &amp;r, const RelationImpl &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Superset: \( r \supseteq s \). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29bd89e59191d79bf4f1df7554104b81"></a><!-- doxytag: member="DomRepr::subset" ref="ga29bd89e59191d79bf4f1df7554104b81" args="(const RelationImpl &amp;r, const RelationImpl &amp;s)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#ga29bd89e59191d79bf4f1df7554104b81">subset</a> (const RelationImpl &amp;r, const RelationImpl &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Proper subset: \( r \subset s \). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga13d6b22060e90a23f2ab1fa1f731d9a1"></a><!-- doxytag: member="DomRepr::superset" ref="ga13d6b22060e90a23f2ab1fa1f731d9a1" args="(const RelationImpl &amp;r, const RelationImpl &amp;s)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#ga13d6b22060e90a23f2ab1fa1f731d9a1">superset</a> (const RelationImpl &amp;r, const RelationImpl &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Proper superset: \( r \supset s \). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga90379fcc833c706ad987eea6ecd3da72"></a><!-- doxytag: member="DomRepr::disjoint" ref="ga90379fcc833c706ad987eea6ecd3da72" args="(const RelationImpl &amp;r, const RelationImpl &amp;s)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#ga90379fcc833c706ad987eea6ecd3da72">disjoint</a> (const RelationImpl &amp;r, const RelationImpl &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjoint: \( r \cap s = \emptyset \). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga877d10098b27c217e740a189d4ca28a2"></a><!-- doxytag: member="DomRepr::complement" ref="ga877d10098b27c217e740a189d4ca28a2" args="(const RelationImpl &amp;r)" -->
RelationImpl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#ga877d10098b27c217e740a189d4ca28a2">complement</a> (const RelationImpl &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complement of relation <em>r</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadb41aed766e7f05c5add32d0f1385c08"></a><!-- doxytag: member="DomRepr::operator&lt;&lt;" ref="gadb41aed766e7f05c5add32d0f1385c08" args="(std::ostream &amp;os, const RelationImpl &amp;r)" -->
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#gadb41aed766e7f05c5add32d0f1385c08">operator&lt;&lt;</a> (std::ostream &amp;os, const RelationImpl &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a relation implementation <em>r</em> in tuple format to <em>os</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga159fcab1f879585c994367e4c2a3823a"></a><!-- doxytag: member="DomRepr::create_equalXY" ref="ga159fcab1f879585c994367e4c2a3823a" args="(void)" -->
RelationImpl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#ga159fcab1f879585c994367e4c2a3823a">create_equalXY</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the binary relation \(R = \{t : t.1 = t.2 \} \). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0394e0da1feb339a85606d6723330691"></a><!-- doxytag: member="DomRepr::create_greaterXY" ref="ga0394e0da1feb339a85606d6723330691" args="(void)" -->
RelationImpl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#ga0394e0da1feb339a85606d6723330691">create_greaterXY</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the binary relation \(R = \{t : t.1 &gt; t.2 \} \). <br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac782f61ff458bae6be56ae139acf5f2f"></a><!-- doxytag: member="DomRepr::bbv" ref="gac782f61ff458bae6be56ae139acf5f2f" args="" -->
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#gac782f61ff458bae6be56ae139acf5f2f">bbv</a> = 5</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits to represent an element inside a relation tuple.The maximum number that can be part of relation's tuple is 2^bbv.</p>
<ul>
<li>Setting this attribute to 5 will allow to represent positive integers of 32 bits. </li>
</ul>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga94df91871e9f299f78b9bdd3f459c804"></a><!-- doxytag: member="DomRepr::ba" ref="ga94df91871e9f299f78b9bdd3f459c804" args="" -->
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#ga94df91871e9f299f78b9bdd3f459c804">ba</a> = 3</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits of the maximum arity that can be representedThe maximum arity that a relation can have is 2^ba.</p>
<ul>
<li>Setting this attribute to 3 will allow to represent up to 8-ary relations. </li>
</ul>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab6b49d4a8e4e331a6d7ec28bbbaf640b"></a><!-- doxytag: member="DomRepr::bitsPerInteger" ref="gab6b49d4a8e4e331a6d7ec28bbbaf640b" args="" -->
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#gab6b49d4a8e4e331a6d7ec28bbbaf640b">bitsPerInteger</a> = 1 &lt;&lt; bbv</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits used to represent each element of a tuple. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga219bea797c7074b1373541a8836c64f7"></a><!-- doxytag: member="DomRepr::arity" ref="ga219bea797c7074b1373541a8836c64f7" args="" -->
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DomRepr.html#ga219bea797c7074b1373541a8836c64f7">arity</a> = 1 &lt;&lt; ba</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits used to represent the arity. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This module provides the support to represent relation domains. </p>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Jun 16 2011 22:04:58 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
